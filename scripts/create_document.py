#!/usr/bin/env python3

import json
import re
import argparse

from pathlib import Path
from util import descend_directory
from create_problems import create_probs


class NameError(Exception):
    pass

class AssignmentNameError(Exception):
    pass


def safestr(x):
    """Return a safe string suitable for use in file/directory names"""
    return re.sub("[^0-9a-zA-z._-]+", "-", x).lower()

__location__ = Path.cwd().joinpath(Path(__file__).parent).resolve()
__root__ = __location__.parent # Set parent directory as root
config = json.loads((__location__ / 'config.json').read_text(encoding='utf-8'))


if __name__ == '__main__':
    # Create arguments for command line
    parser = argparse.ArgumentParser()
    parser.add_argument('doctype', choices=config['document_types'].keys(),
        help="the type of document to create")
    parser.add_argument('title', help="title of the document")
    parser.add_argument('-d', '--directory',
        help="relative directory within documents to write the file; default set in config file")
    parser.add_argument('-f', '--filename',
        help="default filename is set in config.json")
    parser.add_argument('-s', '--replace_string', action='append', nargs=2, 
        metavar=('OLD_STRING', 'NEW_STRING'),
        help="extra strings that need to be specified for the default "\
            "directory/filename (i.e. those contained within @ symbols)")
    args = parser.parse_args()


    # Parse arguments for command
    doc_conf = config['document_types'][args.doctype]
    directory = doc_conf["default_directory"] \
        if args.directory is None else args.directory
    filename = doc_conf["default_filename"] \
        if args.filename is None else args.filename
    if args.replace_string is not None:
        for x, y in args.replace_string:
            filename = filename.replace(f"@{x}@", safestr(y))
            directory = directory.replace(f"@{x}@", safestr(y))
    filename = filename.replace("@title@", safestr(args.title))
    directory = directory.replace("@title@", safestr(args.title))
    if '@' in filename:
        raise NameError("There is a string that hasn't been replaced in the "\
            f"filename: {filename}\n\tDid you forget to use option s?")
    if '@' in directory:
        raise NameError("There is a string that hasn't been replaced in the "\
            f"directory: {directory}\n\tDid you forget to use option s?")


    # Create the contents of the file to be written
    docdepth = len(directory.split('/')) + 1
    contents = ((__root__ / 'templates' / f'{args.doctype}.tex')
        .read_text(encoding='utf-8')
        .replace("TITLE", args.title)
        .replace("ROOTDIR", "/".join([".."] * docdepth))
        .replace("INCLUDES", '\n'.join([
            f"\input{{\\rootdir/includes/{name}.tex}}" \
                for name in doc_conf["includes"]
            ])))
    # Add PROBLEMS for autogenerated document types
    if 'autogenerated' in doc_conf:
        file_list = json.loads((__location__ / doc_conf['autogenerated'])
            .read_text(encoding='utf-8'))
        prob_dict = next(
            (s['problems'] for s in file_list if s['title'] == args.title), None)
        if prob_dict is None:
            raise AssignmentNameError(f"{args.title} is not "\
                "a known assignment name")
        prob_contents = "\\begin{problems}\n"
        for source, probs in prob_dict.items():
            create_probs(source, probs)
            prob_depth = config['problem_sources'][source]['directory_levels']
            depth = 0
            for prob in descend_directory(probs):
                if len(prob.parts) == prob_depth:
                    while depth > 0:
                        depth -= 1
                        prob_contents += ("  " * (depth+1) + "\\end{subproblems}\n")
                    prob_contents += f"  \\{source}prob{{{'/'.join(prob.parts)}}}\n"
                elif len(prob.parts) > prob_depth:
                    while depth < len(prob.parts) - prob_depth:
                        prob_contents += ("  " * (depth+1) + "\\begin{subproblems}\n")
                        depth += 1
                    while depth > len(prob.parts) - prob_depth:
                        depth -= 1
                        prob_contents += ("  " * (depth+1) + "\\end{subproblems}\n")
                    prob_contents += ("  " * (depth+1) + f"\\{source}subprob{{{'/'.join(prob.parts)}}}\n")
            while depth > 0:
                depth -= 1
                prob_contents += ("  " * (depth+1) + "\\end{subproblems}\n")
        prob_contents += "\\end{problems}"
        contents = contents.replace("PROBLEMS", prob_contents)

    # Make any necessary directories and write the file
    path = (__root__ / "documents" / directory)
    path.mkdir(parents=True, exist_ok=True)
    if not (path / filename).exists():
        (path / filename).write_text(contents, encoding="utf-8")
    else: 
        raise FileExistsError(f"{(path / filename)} exists and will not be overwritten. If intended, delete this file first.")