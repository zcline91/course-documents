#!/usr/bin/env python3

import argparse
from pathlib import Path

import yaml

from util import descend_directory, latex_escape, safestr
from create_problems import create_probs


__location__ = Path.cwd().joinpath(Path(__file__).parent).resolve()
__root__ = __location__.parent # Set root directory of repository
CONFIG = yaml.safe_load((__location__ / 'config.yaml')
                        .read_text(encoding='utf-8'))


class NameError(Exception):
    pass


class AssignmentNameError(Exception):
    pass


def _read_args():
    """Set and capture command line arguments"""
    parser = argparse.ArgumentParser()
    parser.add_argument('doctype', choices=CONFIG['document_types'].keys(),
        help="the type of document to create")
    parser.add_argument('title', help="title of the document")
    parser.add_argument('-d', '--directory',
        help="relative directory within documents to write the file; "\
            "default set in config file")
    parser.add_argument('-f', '--filename',
        help="default filename is set in config.json")
    parser.add_argument('-s', '--replace_string', action='append', nargs=2, 
        metavar=('OLD_STRING', 'NEW_STRING'),
        help="extra strings that need to be specified for the default "\
            "directory/filename")
    return parser.parse_args()


def _parse_args(args):
    """Parse the arguments to extract the necessary information for creating
    the LaTeX file. This returns (in order)
    - the title of the document to be created
    - the filename to name it (with extension)
    - the relative path of the documents folder to save the file (as a str)
    - the path to the template for the type of document (as Path)
    - the list of filenames in the includes directory (without extensions)
      to be included with this document type (gathered from the config file)
    - the path to the autogenerate config file for this document type if 
      found in the config file, otherwise None
    - the dict of extra_version information (found in the config file)
      or None"""
    doc_conf = CONFIG['document_types'][args.doctype]
    directory = doc_conf["default_directory"] \
        if args.directory is None else args.directory
    filename = doc_conf["default_filename"] \
        if args.filename is None else args.filename
    repl_str_dict = {"title": safestr(args.title)}
    if args.replace_string is not None:
        repl_str_dict.update({x: safestr(y) for x, y in args.replace_string})
    try:
        filename = filename % repl_str_dict
    except KeyError:
        raise NameError("There is a string that hasn't been replaced in the "\
            f"filename: {filename}\n\tDid you forget to use option s?")
    try:
        directory = directory % repl_str_dict
    except KeyError:
        raise NameError("There is a string that hasn't been replaced in the "\
            f"filename: {directory}\n\tDid you forget to use option s?")
    template_path = (__root__ / 'templates' / f'{args.doctype}.tex')
    autogen_config_path = (__location__ / doc_conf['autogenerated']) \
        if 'autogenerated' in doc_conf else None
    extra_versions = doc_conf.get('extra_versions', None)
    return (args.title, filename, directory, template_path, 
            doc_conf['includes'], autogen_config_path, 
            extra_versions)


def _get_autogen_problem_contents(prob_dict):
    """Generate the LaTeX source for including the problems in 
    prob_dict into an autogenerated file. (This should generate what
    will replace "PROBLEMS" in the template.)"""
    prob_contents = "\\begin{problems}\n"
    for source, probs in prob_dict.items():
        create_probs(source, probs)
        prob_depth = CONFIG['problem_sources'][source]['directory_levels']
        depth = 0
        for prob in descend_directory(probs):
            if len(prob.parts) == prob_depth:
                while depth > 0:
                    depth -= 1
                    prob_contents += ("  " * (depth+1) +
                                        "\\end{subproblems}" + "\n")
                prob_contents += (f"  \\{source}prob" 
                                    f"{{{'/'.join(prob.parts)}}}\n")
            elif len(prob.parts) > prob_depth:
                while depth < len(prob.parts) - prob_depth:
                    prob_contents += ("  " * (depth+1) + 
                                        "\\begin{subproblems}\n")
                    depth += 1
                while depth > len(prob.parts) - prob_depth:
                    depth -= 1
                    prob_contents += ("  " * (depth+1) + 
                                        "\\end{subproblems}\n")
                prob_contents += ("  " * (depth+1) + 
                        f"\\{source}subprob{{{'/'.join(prob.parts)}}}\n")
        while depth > 0:
            depth -= 1
            prob_contents += ("  " * (depth+1) + "\\end{subproblems}\n")
    prob_contents += "\\end{problems}"
    return prob_contents


def main():
    # Capture and parse arguments from command line to get the necessary
    # information for creating the LaTeX file(s).
    args = _read_args()
    title, filename, directory, template_path, includes, \
        autogen_config_path, extra_versions = _parse_args(args)
    # Create the initial contents of the file to be written using template
    docdepth = len(directory.split('/')) + 1
    contents = (template_path
        .read_text(encoding='utf-8')
        .replace("TITLE", latex_escape(args.title))
        .replace("ROOTDIR", "/".join([".."] * docdepth))
        .replace("INCLUDES", '\n'.join([
            f"\input{{\\rootdir/includes/{name}.tex}}" \
                for name in includes
            ])))
    # Add PROBLEMS for autogenerated document types
    if autogen_config_path is not None:
        file_list = yaml.safe_load(autogen_config_path
            .read_text(encoding='utf-8'))
        try:
            prob_dict = file_list[title]
        except KeyError:
            raise AssignmentNameError(f"{title} is not a known "
                                      "assignment name")
        prob_contents = _get_autogen_problem_contents(prob_dict)
        contents = contents.replace("PROBLEMS", prob_contents)
    # Make any necessary directories and write the file
    path = (__root__ / "documents" / directory)
    path.mkdir(parents=True, exist_ok=True)
    if not (path / filename).exists():
        (path / filename).write_text(contents, encoding="utf-8")
    else: 
        raise FileExistsError(f"{(path / filename)} exists and will not be "
            "overwritten. If intended, delete this file first.")
    # Make extra-versions
    if extra_versions is not None:
        for name, ev_config in extra_versions.items():
            extra_filename = (f"{Path(filename).stem}-"
                f"{name}{Path(filename).suffix}")
            contents = (f"\PassOptionsToClass{{{ev_config['options']}}}"
                f"{{{ev_config['class']}}}\n\input{{{filename}}}")
            if not (path / extra_filename).exists():
                (path / extra_filename).write_text(contents, encoding="utf-8")
            else:
                raise FileExistsError(f"{(path / extra_filename)} exists "
                    "and will not be overwritten. If intended, delete this "
                    "file first.")


if __name__ == '__main__':
    main()
