#!/usr/bin/env python3

import re
import argparse
from pathlib import Path

import yaml

from util import descend_directory, latex_escape
from create_problems import create_probs


__location__ = Path.cwd().joinpath(Path(__file__).parent).resolve()
__root__ = __location__.parent # Set root directory of repository
config = yaml.safe_load((__location__ / 'config.yaml')
                        .read_text(encoding='utf-8'))


class NameError(Exception):
    pass


class AssignmentNameError(Exception):
    pass


def safestr(x):
    """Return a version of the string x suitable for use in 
    file/directory names"""
    return re.sub("[^0-9a-zA-z._-]+", "-", x).lower()


def read_args():
    """Set and capture command line arguments"""
    parser = argparse.ArgumentParser()
    parser.add_argument('doctype', choices=config['document_types'].keys(),
        help="the type of document to create")
    parser.add_argument('title', help="title of the document")
    parser.add_argument('-d', '--directory',
        help="relative directory within documents to write the file; "\
            "default set in config file")
    parser.add_argument('-f', '--filename',
        help="default filename is set in config.json")
    parser.add_argument('-s', '--replace_string', action='append', nargs=2, 
        metavar=('OLD_STRING', 'NEW_STRING'),
        help="extra strings that need to be specified for the default "\
            "directory/filename")
    return parser.parse_args()


def parse_args(args):
    doc_conf = config['document_types'][args.doctype]
    directory = doc_conf["default_directory"] \
        if args.directory is None else args.directory
    filename = doc_conf["default_filename"] \
        if args.filename is None else args.filename
    repl_str_dict = {"title": safestr(args.title)}
    if args.replace_string is not None:
        repl_str_dict.update({x: safestr(y) for x, y in args.replace_string})
    try:
        filename = filename % repl_str_dict
    except KeyError:
        raise NameError("There is a string that hasn't been replaced in the "\
            f"filename: {filename}\n\tDid you forget to use option s?")
    try:
        directory = directory % repl_str_dict
    except KeyError:
        raise NameError("There is a string that hasn't been replaced in the "\
            f"filename: {directory}\n\tDid you forget to use option s?")
    return (doc_conf, filename, directory)


if __name__ == '__main__':
    args = read_args() # Capture arguments from command line
    doc_conf, filename, directory = parse_args(args)
    # Create the contents of the file to be written
    docdepth = len(directory.split('/')) + 1
    contents = ((__root__ / 'templates' / f'{args.doctype}.tex')
        .read_text(encoding='utf-8')
        .replace("TITLE", latex_escape(args.title))
        .replace("ROOTDIR", "/".join([".."] * docdepth))
        .replace("INCLUDES", '\n'.join([
            f"\input{{\\rootdir/includes/{name}.tex}}" \
                for name in doc_conf["includes"]
            ])))
    # Add PROBLEMS for autogenerated document types
    if 'autogenerated' in doc_conf:
        file_list = yaml.safe_load((__location__ / doc_conf['autogenerated'])
            .read_text(encoding='utf-8'))
        try:
            prob_dict = file_list[args.title]
        except KeyError:
            raise AssignmentNameError(f"{args.title} is not a known "
                                      "assignment name")
        prob_contents = "\\begin{problems}\n"
        for source, probs in prob_dict.items():
            create_probs(source, probs)
            prob_depth = config['problem_sources'][source]['directory_levels']
            depth = 0
            for prob in descend_directory(probs):
                if len(prob.parts) == prob_depth:
                    while depth > 0:
                        depth -= 1
                        prob_contents += ("  " * (depth+1) +
                                          "\\end{subproblems}" + "\n")
                    prob_contents += (f"  \\{source}prob" 
                                      f"{{{'/'.join(prob.parts)}}}\n")
                elif len(prob.parts) > prob_depth:
                    while depth < len(prob.parts) - prob_depth:
                        prob_contents += ("  " * (depth+1) + 
                                          "\\begin{subproblems}\n")
                        depth += 1
                    while depth > len(prob.parts) - prob_depth:
                        depth -= 1
                        prob_contents += ("  " * (depth+1) + 
                                          "\\end{subproblems}\n")
                    prob_contents += ("  " * (depth+1) + 
                            f"\\{source}subprob{{{'/'.join(prob.parts)}}}\n")
            while depth > 0:
                depth -= 1
                prob_contents += ("  " * (depth+1) + "\\end{subproblems}\n")
        prob_contents += "\\end{problems}"
        contents = contents.replace("PROBLEMS", prob_contents)

    # Make any necessary directories and write the file
    path = (__root__ / "documents" / directory)
    path.mkdir(parents=True, exist_ok=True)
    if not (path / filename).exists():
        (path / filename).write_text(contents, encoding="utf-8")
    else: 
        raise FileExistsError(f"{(path / filename)} exists and will not be "
            "overwritten. If intended, delete this file first.")

    # Make extra-versions
    if "extra-versions" in doc_conf:
        for name, config in doc_conf["extra-versions"].items():
            extra_filename = (f"{Path(filename).stem}-"
                f"{name}{Path(filename).suffix}")
            contents = (f"\PassOptionsToClass{{{config['options']}}}"
                f"{{{config['class']}}}\n\input{{{filename}}}")
            if not (path / extra_filename).exists():
                (path / extra_filename).write_text(contents, encoding="utf-8")
            else:
                raise FileExistsError(f"{(path / extra_filename)} exists "
                    "and will not be overwritten. If intended, delete this "
                    "file first.")